<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>WASI Marshalling</h1>
<p>This library provides two things:</p>
<ul>
<li>The minimum WASI implementation required for supporting  memory allocation
and strings.</li>
<li>A marshalling framework for calling WebAssembly functions in a wasm module
from JavaScript.</li>
</ul>
<p>The intention is to provide support to &quot;drop in&quot; publically available libraries
that can be compiled into a wasm module.</p>
<h2>The WASI Layer</h2>
<p>Three WASI domains are implemented:</p>
<ul>
<li>stout/stderr - many libraries fall back to reporting errors over the standard
output/error. These are redirected to <code>console.log</code> and <code>console.error</code>.</li>
<li>string passing with UTF-8 requires a call to <code>setlocale</code> which in turn
requires a system call to request environment variables. This call is
intercepted, and returns a application provided set of the environment
variables.</li>
<li>memory management - most libraries make use of <code>malloc</code> and <code>free</code> to manage
memory.</li>
</ul>
<p>The implementation of the WASI layer is provided through a class of the
same name. Here is an example of initialising the library.</p>
<pre class="prettyprint source lang-javascript"><code>import { Wasi } from '@jetblack/wasi-marshalling'

// Create the Wasi instance passing in environment variables.
const wasi = new Wasi({})

// Instantiate the wasm module.
WebAssembly.instantiateStreaming(
  fetch('example.wasm'), {
    wasi_snapshot_preview1: wasi.imports()
  })
  .then(res => {
    // Initialise the wasi instance
    wasi.init(res.instance)

    // Do something interesting ...
  })
</code></pre>
<h2>The Marshalling Framework</h2>
<h3>Introduction</h3>
<p>Given the following C function call which multiplies two arrays.</p>
<pre class="prettyprint source lang-C"><code>#include &lt;stdlib.h>

__attribute__((used)) double* multipleFloat64ArraysReturningPtr (double* array1, double* array2, int length)
{
  double* result = (double*) malloc(length * sizeof(double));
  if (result == 0)
    return 0;

  for (int i = 0; i &lt; length; ++i) {
    result[i] = array1[i] + array2[i];
  }

  return result;
}
</code></pre>
<p>We can define and call the following function prototype.</p>
<pre class="prettyprint source lang-javascript"><code>import {
  ArrayType,
  Float64Type,
  Int32Type,
  FunctionPrototype,
  In
} from '@jetblack/wasi-marshalling.develop.js'

const prototype = new FunctionPrototype(
  // The arguments
  [
    new In(new ArrayType(new Float64Type())),
    new In(new ArrayType(new Float64Type())),
    new In(new Int32Type())
  ],
  // The return type
  new ArrayType(new Float64Type(), 4)
)

const result = prototype.invoke(
  wasi.memoryManager,
  wasi.instance.exports.multipleFloat64ArraysReturningPtr,
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  4)

console.log(result)
</code></pre>
<p>The framework will take care of passing the data to the wasm module,
unpacking the result and allocating/deallocating the memory.</p>
<h3>Finalizers and Typed Arrays</h3>
<p>A recent introduction to JavaScript is the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry">FinalizationRegistry</a>.
This allows us to register a function to call when an object is garbage
collected. We can use this to handle memory management in WebAssembly.</p>
<p>The
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">TypedArray</a>
family of objects provide transparant interoperability between Javascript and
WebAssembly. Rather than copying values (as with <code>ArrayType</code>) we can simply pass a
<code>TypedArray</code> via `TypedArrayType&quot;. The prototype fot the above functions would
look like this:</p>
<pre class="prettyprint source lang-javascript"><code>import {
  TypedArrayType,
  Float64Type,
  Int32Type,
  FunctionPrototype,
  In
} from '@jetblack/wasi-marshalling.develop.js'

const proto = new FunctionPrototype(
  [
    new In(new TypedArrayType(new Float64Type())),
    new In(new TypedArrayType(new Float64Type())),
    new In(new Int32Type())
  ],
  new TypedArrayType(new Float64Type(), 4)
)

const result = proto.invoke(
  wasi.memoryManager,
  wasi.instance.exports.multipleFloat64ArraysReturningPtr,
  wasi.memoryManager.createTypedArray(Float64Array, [1, 2, 3, 4]),
  wasi.memoryManager.createTypedArray(Float64Array, [5, 6, 7, 8]),
  4)

console.log(result)
</code></pre>
<p>Note how we call <code>createTypedArray</code> from the memory manager. This allocates
the memory and registers the pointer with the finalizer to ensure the memory
gets freed.</p>
<h3>Types</h3>
<p>The framework handles the following types:</p>
<ul>
<li>Int8, Int16, Int32, Int64</li>
<li>Uint8, Uint16, Uint32, Uint64</li>
<li>Float32, Float64</li>
<li>String</li>
<li>Array</li>
<li>Pointer</li>
</ul>
<h2>Usage</h2>
<p>To build the package:</p>
<pre class="prettyprint source lang-bash"><code>npm install
npm run build
</code></pre>
<p>To Run the examples in the <code>client</code> folder.</p>
<pre class="prettyprint source lang-bash"><code># Run a node example
npm run exec:nodejs
# Run code in a `&lt;script>` tag in the browser
npm run exec:browser
</code></pre></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AddressType.html">AddressType</a></li><li><a href="ArgumentDef.html">ArgumentDef</a></li><li><a href="ArrayType.html">ArrayType</a></li><li><a href="Float32Type.html">Float32Type</a></li><li><a href="Float64Type.html">Float64Type</a></li><li><a href="FunctionPrototype.html">FunctionPrototype</a></li><li><a href="In.html">In</a></li><li><a href="InOut.html">InOut</a></li><li><a href="Int8Type.html">Int8Type</a></li><li><a href="Int16Type.html">Int16Type</a></li><li><a href="Int32Type.html">Int32Type</a></li><li><a href="Int64Type.html">Int64Type</a></li><li><a href="MemoryManager.html">MemoryManager</a></li><li><a href="Out.html">Out</a></li><li><a href="Pointer.html">Pointer</a></li><li><a href="PointerType.html">PointerType</a></li><li><a href="ReferenceType.html">ReferenceType</a></li><li><a href="StringBuffer.html">StringBuffer</a></li><li><a href="StringBufferType.html">StringBufferType</a></li><li><a href="StringType.html">StringType</a></li><li><a href="Type.html">Type</a></li><li><a href="global.html#TypedArrayType">TypedArrayType</a></li><li><a href="Uint8Type.html">Uint8Type</a></li><li><a href="Uint16Type.html">Uint16Type</a></li><li><a href="Uint32Type.html">Uint32Type</a></li><li><a href="Uint64Type.html">Uint64Type</a></li><li><a href="ValueType.html">ValueType</a></li><li><a href="Wasi.html">Wasi</a></li></ul><h3>Global</h3><ul><li><a href="global.html#strlen">strlen</a></li><li><a href="global.html#unmarshalledArgs%255Bundefined%255D">unmarshalledArgs[undefined]</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Fri Jul 10 2020 13:03:40 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>